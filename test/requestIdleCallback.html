<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
   <style>
     .container{
         padding: 30px;
     }
     .logBox{
         padding: 30px;
         border: 1px solid red;
     }
     .button{
         padding: 10px;
         background-color: red;
         width: 90px;
         cursor: pointer;
     }
     #log{
         height: 500px;
         overflow: auto;
         border: 1px solid #000;
     }

   </style>
</head>
<body>
  
<p>
    演示使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API">
     协作调度幕后任务 </a> 使用 <code>requestIdleCallback()</code>
    方法.
  </p>
  
  <div class="container">
    <div class="label">解码量子丝极谱发射中...</div>
    <progress id="progress" value="0"></progress>
    <div class="button" id="startButton">
      开始
    </div>
    <div class="label counter">
      任务 <span id="currentTaskNumber">0</span> / <span id="totalTaskCount">0</span>
    </div>
  </div>
  
  <div class="logBox">
    <div class="logHeader">
      记录
    </div>
    <div id="log">
    </div>
  </div>

    <script>
        window.cancelIdleCallback = window.cancelIdleCallback || function(id) {
          clearTimeout(id);
        };
       window.requestIdleCallback = window.requestIdleCallback || function(handler) {
            let startTime = Date.now();
            console.log('false idle');
            return setTimeout(function() {
                handler({
                didTimeout: false,
                timeRemaining: function() {
                    return Math.max(0, 50.0 - (Date.now() - startTime));
                }
                });
            }, 1);
        };
        // 任务调度器
        let TaskScheduleRunner = {
            taskList: [],
            totalTaskCount: 0, //是一个已被添加到队列的任务数量计数器，只会增大，不会减小。我们用它计算总工作量进度的百分比值
            currentTaskNumber: 0, //用于追踪到现在为止已处理了多少任务,
            taskHandle: null, //是对当前处理中任务的一个引用。
            updateDisplay: function() {}, //更新页面布局的函数
            statusRefreshScheduled: false, // 是否正在更新页面,
            setStatusRefreshScheduled(val) {
               this.statusRefreshScheduled = val;
            },
            enqueueTask(taskHandler, taskData) { //添加任务
                let k = this;
                k.taskList.push({
                    handler: taskHandler,
                    data: taskData
                });

                k.totalTaskCount++;
                if (!k.taskHandle) {
                    k.taskHandle = requestIdleCallback(k.runTaskQueue.bind(k), { timeout: 1000 });
                }

                k.scheduleStatusRefresh(k.updateDisplay);
            },
            runTaskQueue(deadline) {//空闲时间运行任务
                let k = this;
                console.log('------------------------new running---------------------------');
                while((deadline.timeRemaining() > 0 || deadline.didTimeout) && k.taskList.length) {
                    console.log('deadline.timeRemaining() : '+deadline.timeRemaining());
                    let task = k.taskList.shift();
                    k.currentTaskNumber++;
                    task.handler(task.data);
                    k.scheduleStatusRefresh(k.updateDisplay);
                }
                if(k.taskList.length) {
                    k.taskHandle = requestIdleCallback(k.runTaskQueue.bind(k), {timeout: 1000});
                } else {
                    k.taskHandle = 0;
                }
            },
            scheduleStatusRefresh(updateDisplay) {
                let k = this;
                if(!k.statusRefreshScheduled) {
                    requestAnimationFrame(updateDisplay);
                    k.statusRefreshScheduled = true;
                }
            },
            

        };
        

        (function() {
     

            let totalTaskCountElem = document.getElementById("totalTaskCount");
            let currentTaskNumberElem = document.getElementById("currentTaskNumber");
            let progressBarElem = document.getElementById("progress");
            let startButtonElem = document.getElementById("startButton");
            let logElem = document.getElementById("log");
            /*
            logFragment 当渲染下一帧，我们的记录方法都会生成一个 DocumentFragment 来创建添加到记录的内容，并保存到logFragment中 DocumentFragment 。
statusRefreshScheduled 我们用它来追踪我们是否已经为即将到来的帧安排了状态显示框的更新，所以我们每一帧只执行一次。
            */
            let logFragment = null;
            let statusRefreshScheduled = false;
            function updateDisplay() {
                let scrolledToEnd = logElem.scrollHeight - logElem.clientHeight <= logElem.scrollTop + 1;
                 let totalTaskCount = TaskScheduleRunner.totalTaskCount;
                 let currentTaskNumber = TaskScheduleRunner.currentTaskNumber;
                if (totalTaskCount) {
                    if (progressBarElem.max != totalTaskCount) {
                    totalTaskCountElem.textContent = totalTaskCount;
                    progressBarElem.max = totalTaskCount;
                    }

                    if (progressBarElem.value != currentTaskNumber) {
                    currentTaskNumberElem.textContent = currentTaskNumber;
                    progressBarElem.value = currentTaskNumber;
                    }
                }

                if (logFragment) {
                    logElem.appendChild(logFragment);
                    logFragment = null;
                }

                if (scrolledToEnd) {
                    logElem.scrollTop = logElem.scrollHeight - logElem.clientHeight;
                }

                TaskScheduleRunner.setStatusRefreshScheduled(false);
            }

            function log(text) {
                if (!logFragment) {
                    logFragment = document.createDocumentFragment();
                }

                let el = document.createElement("div");
                el.innerHTML = text;
                logFragment.appendChild(el);
            }

            function logTaskHandler(data) {
                log("<strong>Running task #" + TaskScheduleRunner.currentTaskNumber + "</strong>");

                for (i=0; i<data.count; i+=1) {
                    log((i+1).toString() + ". " + data.text);
                }
            }

            function getRandomIntInclusive(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值 
            }



            //入口
            function decodeTechnoStuff() {
            
                TaskScheduleRunner.totalTaskCount = 0;
                TaskScheduleRunner.currentTaskNumber = 0;
                TaskScheduleRunner.updateDisplay = updateDisplay;
                updateDisplay();

                let n = getRandomIntInclusive(100, 200);

                for (i=0; i<n; i++) {
                    let taskData = {
                    count: getRandomIntInclusive(75, 150),
                    text: "This text is from task number " + (i+1).toString() + " of " + n
                };

                TaskScheduleRunner.enqueueTask(logTaskHandler, taskData);
                }
            }
            console.log('here');
            document.getElementById("startButton").addEventListener("click", decodeTechnoStuff, false);
        })();
       


    </script>
</body>
</html>